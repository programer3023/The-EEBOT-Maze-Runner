;*****************************************************************

;* This stationery serves as the framework for a                 *

;* user application (single file, absolute assembly application) *

;* For a more comprehensive program that                         *

;* demonstrates the more advanced functionality of this          *

;* processor, please see the demonstration applications          *

;* located in the examples subdirectory of the                   *

;* Freescale CodeWarrior for the HC12 Program directory          *

;*****************************************************************



              XDEF Entry, _Startup ; export ‘Entry’ symbol

              ABSENTRY Entry ; for absolute assembly: mark

              INCLUDE "derivative.inc"



;***************************************************************************************************

; equates section

;***************************************************************************************************





; LCD Addresses  -Taken from provided Guider code


; -------------

LCD_CNTR      EQU   PTJ                   ; LCD Control Register: E = PJ7, RS = PJ6

LCD_DAT       EQU   PORTB                 ; LCD Data Register: D7 = PB7, ... , D0 = PB0

LCD_E         EQU   $80                   ; LCD E-signal pin

LCD_RS        EQU   $40                   ; LCD RS-signal pin



; States for robot

;-----------------                                     

START         EQU   0                     ;Start State

FWD           EQU   1                     ;Forward State

ALL_STP       EQU   2                     ;All Stop State

L_TRN         EQU   3                     ;Left Turn State

R_TRN         EQU   4                     ;Right Turn State

RV_TRN        EQU   5                     ;Reverse Turn State

L_ALIGN       EQU   6                     ;Straigntens the robots pathing 

R_ALIGN       EQU   7                     ; 



; Liquid Crystal Display Equates -Taken from provided Guider code

;-------------------------------

CLEAR_HOME    EQU   $01                   ; Clear the display and home the cursor

INTERFACE     EQU   $38                   ; 8 bit interface, two line display

CURSOR_OFF    EQU   $0C                   ; Display on, cursor off

SHIFT_OFF     EQU   $06                   ; Address increments, no character shift

LCD_SEC_LINE  EQU   64                    ; Starting addr. of 2nd line of LCD (note decimal value!)

NULL          EQU   00                    ; The string ’null terminator’

CR            EQU   $0D                   ; ’Carriage Return’ character

SPACE         EQU   ' '                   ; The ’space’ character



; Turning Timers

;---------------

T_L           EQU   7

T_R           EQU   7






; variable/data section

; ---------------------

              ORG   $3800

             

             

; Storage Registers (9S12C32 RAM space: $3800 ... $3FFF) -Taken from provided Guider code


; ------------------------------------------------------

SENSOR_LINE   FCB   $01                     ; Storage for guider sensor readings

SENSOR_BOW    FCB   $23                     ; Initialized to test values

SENSOR_PORT   FCB   $45

SENSOR_MID    FCB   $67

SENSOR_STBD   FCB   $89

SENSOR_NUM    RMB   1                       ; The currently selected sensor



; Initial values based on the initial readings & variance

; -------------------------------------------------------

B_LINE     FCB   $70                       ;Adresses from our ebot version 

B_BOW      FCB   $7F

B_MID      FCB   $AE

B_PORT     FCB   $8F

B_STBD     FCB   $8F

                                           

V_LINE      FCB   $18                     ; Variance for each sensor to make sure

V_BOW       FCB   $30                     ; that the robot adjusts itself properly

V_PORT      FCB   $20                     ; 

V_MID       FCB   $20                     ; 
V_STBD      FCB   $15



TOP_LINE      RMB   20                    ; Top line display

              FCB   NULL                  ; terminated by null

             

BOT_LINE      RMB   20                    ; Bottom line display

              FCB   NULL                  ; terminated by null

             

CLEAR_LINE    FCC   '                  '  ; Clear the line display

              FCB   NULL                  ; terminated by null

             

TEMP          RMB   1                     ; Random temporary location





; variable section

;***************************************************************************************************

              ORG   $3850                   ; Address of the TOF counter

TOF_COUNTER   dc.b  0                       ; Timer at 23Hz

CRNT_STATE    dc.b  2                       ; Current state register

T_TURN        ds.b  1                       ; The time to stop ebot from turning

NO_BLANK      ds.b  1                       ; 
HEX_TABLE     FCC   '0123456789ABCDEF'      ; 
BCD_SPARE     RMB   2

TEN_THOUS     ds.b  1                       ; Ten-thousand digit

THOUSANDS     ds.b  1                       ; Thousand digit

HUNDREDS      ds.b  1                       ; Hundred digit

TENS          ds.b  1                       ; Ten digit

UNITS         ds.b  1                       ; One digit



; code section

;***************************************************************************************************

              ORG   $4000

Entry:                                                                      

_Startup:



;Initialization



              LDS   #$4000                 ; 
              CLI                          ; 

              JSR   INIT                   ; Initialize ports, ADC and LCD
              JSR   openADC                ; 
              JSR   initLCD                ; 
              JSR   CLR_LCD_BUF            ; Write characters to the LCD buffer                     I

              BSET  DDRA,%00000011         ; 
              BSET  DDRT,%00110000         ; 
                                                                               

              JSR   initAD                 ; Initialize ATD converter and LCD                                                                                                   
              JSR   initLCD                ;                      

              JSR   clrLCD                 ; Clears LCD & home cursor                  

                                                                               

              LDX   #msg1                  ; Displays msg1                              

              JSR   putsLCD                ;                                        

                                                                               

              LDAA  #$8A                   ; Moves LCD cursor to the 2nd row          

              JSR   cmd2LCD                ;                                          

              LDX   #msg2                  ; Displays msg2                              
                                                    
              JSR   putsLCD 

              

              LDAA   #$C0                  ;             

             

              LDX   #msg3                  ; Display msg3                              

              JSR   putsLCD                ;                                        

                                                                               

              LDAA  #$C7                   ; Moves LCD cursor to the 2nd row          

              JSR   cmd2LCD                ;                                          

              LDX   #msg4                  ; Displays msg4                              

              JSR   putsLCD                ;             

             

              JSR   ENABLE_TOF             ; Jumps to TOF initialization

           



MAIN        

              JSR   G_LEDS_ON              ; Enable the guider LEDs  

              JSR   READ_SENSORS           ; Reads the ebots guider sensors                      

              JSR   G_LEDS_OFF             ; Disables the guider LEDs          

             

              JSR   UPDT_DISPL         ; 

              LDAA  CRNT_STATE         ;                                           

              JSR   DISPATCHER         ;                                           

              BRA   MAIN               ;

             

; data section

;***************************************************************************************************

msg1          dc.b  "S: ",0         ;Current State 

msg2          dc.b  "R: ",0         ;Sensor readings 

msg3          dc.b  "V: ",0         ;Battery Voltage 

msg4          dc.b  "B: ",0         ;Status of bumper 

tab           dc.b  "START  ",0

              dc.b  "FWD    ",0

              dc.b  "ALL_STP",0

              dc.b  "LTURN  ",0

              dc.b  "RTURN  ",0

              dc.b  "REVTURN ",0

              dc.b  "LTimed ",0    

              dc.b  "RTimed ",0  

                 

; subroutine section

;***************************************************************************************************

; Start of the Dispatcher                                                                   



DISPATCHER        JSR   CHCK_STRT                           
                  RTS

               

CHCK_STRT         CMPA  #START                              ; Checks if the state that the ebot is in (respective for each start,forward, stop, left-turn, right-turn, sreverse-turn,left-allign, right-allign)

                  BNE   CHCK_FWD                            ; Otherwise it will go check the next state

                  JSR   START_ST                            ; Moves to the respective state

                  RTS                                       ; rtarts that respective state



CHCK_FWD          CMPA  #FWD                               
                  BNE   CHCK_STP                           

                  JSR   FWD_ST                           
                  RTS                                      



CHCK_STP          CMPA  #ALL_STP                          
                  BNE   CHCK_L_TRN                        

                  JSR   ALL_STP_ST                         

                  RTS                                      


CHCK_L_TRN        CMPA  #L_TRN                             

                  BNE   CHCK_R_TRN                        
                  JSR   FULL_L                             

                  RTS                                     


CHCK_R_TRN        CMPA  #R_TRN                             

                  BNE   CHCK_RV_TRN                         
                  JSR   FULL_R                             
                  RTS                                      
                 

CHCK_RV_TRN       CMPA  #RV_TRN                            
                  BNE   CHCK_L_ALIGN                        

                  JSR   REV_TURN_ST                        
                  RTS                                       
                 

CHCK_L_ALIGN     CMPA  #L_ALIGN                            
                  BNE   CHCK_R_ALIGN                      

                  JSR   LEFT_ALIGN_EXIT                     
                  RTS                                       



CHCK_R_ALIGN      CMPA  #R_ALIGN                            

                  BNE   INVALID_STATE                      

                  JSR   RIGHT_ALIGN_EXIT                    
                  RTS                                      

                     

INVALID_STATE     SWI                                       ; Break monitor if none of the conditions are met

    





;Dispatcher Subroutines

;***************************************************************************************************



; -------------------------------------------------------------------------------------------------

; Start subroutine: will only go into starting state if the front bumper is touched                                                                                

;   

START_ST          BRCLR   PORTAD0, %00000100, NO_START                                  

                  JSR     INIT_FWD                                                                

                  MOVB    #FWD, CRNT_STATE                                                      

NO_START  RTS                                                                            

; -------------------------------------------------------------------------------------------------





; -------------------------------------------------------------------------------------------------

; Forward Subroutine:    

;  The robot turns around if the front bumper is hit                                                                        
;  Stops if back bumber is hit                       
;  if none of the bumpers are touched then the robot will continue following the line and
;  adjusts if its not on the line

; -------------------------------------------------------------------------------------------------              

FWD_ST            BRSET   PORTAD0, %00000100, NO_FWD_BUMP           ; Checks if the front bumper is hit,                         

                  MOVB    #RV_TRN, CRNT_STATE                       ; Turns around if true                                  

                                                                    ;                             

                  JSR     UPDT_DISPL                                ; Update the display                             

                                                                                                 

                  JSR     INIT_REV                                                                

                  LDY     #6000                                                                   

                  JSR     del_50us                                                               

                                                                                                

                  JSR     INIT_RIGHT                                                              

                  LDY     #6000                                                                  

                  JSR     del_50us                                                                

                  LBRA    EXIT                                                                    

                                                                                                 

NO_FWD_BUMP       BRSET   PORTAD0, %00001000, NO_FWD_REAR_BUMP      ; Checks if the back bumper is hit  

                  MOVB    #ALL_STP, CRNT_STATE                      ;                               

                  JSR     INIT_STOP                                 ; stops if true               

                  LBRA    EXIT                                                                    

                                                                                                 

                                                                                                  
                                                                

                                                                                                  

NO_FWD_REAR_BUMP  LDAA    SENSOR_BOW                    ; The following reads the robots sensors and adds variance                                         
                                                        ; this varience helps in adjusting the bots pathing by comparing them
                  ADDA    V_BOW                                                                 

                  CMPA    B_BOW                                                                

                  BPL     NO_ALIGN                                                                

                                                                                                  

                  LDAA    SENSOR_MID                                                              

                  ADDA    V_MID                                                                

                  CMPA    B_MID                                                                

                  BPL     NO_ALIGN                                                                

                                                                                                  

                  LDAA    SENSOR_LINE                                                             

                  ADDA    V_LINE                                                                

                  CMPA    B_LINE                                                               

                  BPL     GO_RIGHT_ALIGN                                                          

                                                                                                  

                  LDAA    SENSOR_LINE                                                             

                  SUBA    V_LINE                                                                

                  CMPA    B_LINE                                                               

                  BMI     GO_LEFT_ALIGN                                                           

                                                                                                  

NO_ALIGN          LDAA    SENSOR_PORT                                                            

                  ADDA    V_PORT                                                                

                  CMPA    B_PORT                                                               

                  BPL     PART_LEFT_TURN                                                          

                  BMI     NO_PORT_DET                                                             

                                                                                                  

NO_PORT_DET       LDAA    SENSOR_BOW                                                              

                  ADDA    V_BOW                                                                 

                  CMPA    B_BOW                                                                

                  BPL     EXIT                                                                    

                  BMI     NO_BOW_DET                                                              

                                                                                                  

NO_BOW_DET                                                                                       

                  LDAA    SENSOR_STBD                                                            

                  ADDA    V_STBD                                                                

                  CMPA    B_STBD                                                               

                  BPL     PART_RIGHT_TURN                                                        

                  BMI     EXIT                                                                    

                                                                                                  

PART_LEFT_TURN    LDY     #6000                                                                   

                  jsr     del_50us                                                                

                  JSR     INIT_LEFT                                                               

                  MOVB    #L_TRN, CRNT_STATE                                                  

                  LDY     #6000                                                                   

                  JSR     del_50us                                                                

                  BRA     EXIT                                                                    

                                                                                                  

PART_RIGHT_TURN   LDY     #6000                                                                   

                  jsr     del_50us                                                                

                  JSR     INIT_RIGHT                                                              

                  MOVB    #R_TRN, CRNT_STATE                                                 

                  LDY     #6000                                                                   

                  JSR     del_50us                                                                

                  BRA     EXIT                                                                    

                                                                                                  

GO_LEFT_ALIGN     JSR     INIT_LEFT                                                               

                  MOVB    #L_ALIGN, CRNT_STATE                                                 

                  BRA     EXIT                                                                    

                                                                                                 

GO_RIGHT_ALIGN    JSR     INIT_RIGHT                                                              

                  MOVB    #R_ALIGN, CRNT_STATE        ; Adjusts the bot while it goes forward to stay on the line                               

                  BRA     EXIT                                                                    



EXIT              RTS                                                                             

            

FULL_L            LDAA    SENSOR_BOW                   ;The following is used to make the bot turn make a left or right turn at an intersection of the line                                           

                  ADDA    V_BOW                                                               

                  CMPA    B_BOW                                                                

                  BPL     LEFT_ALIGN_EXIT                                                         

                  BMI     EXIT                                                                                                                                                       

                   

LEFT_ALIGN_EXIT   MOVB    #FWD, CRNT_STATE                                                      

                  JSR     INIT_FWD                                                               

                  BRA     EXIT

                                                                                     

FULL_R            LDAA    SENSOR_BOW                                                            

                  ADDA    V_BOW                                                                 

                  CMPA    B_BOW                                                                

                  BPL     RIGHT_ALIGN_EXIT                                                      

                  BMI     EXIT                                                                    



RIGHT_ALIGN_EXIT  MOVB    #FWD, CRNT_STATE                                                        

                  JSR     INIT_FWD                                                                

                  BRA     EXIT                                                                    

                                                                                                  

REV_TURN_ST       LDAA    SENSOR_BOW                                                              

                  ADDA    V_BOW                                                                 

                  CMPA    B_BOW                                                                

                  BMI     EXIT                                                                    

                                                                                                  

                  JSR     INIT_LEFT                                                              

                  MOVB    #FWD, CRNT_STATE                                                        

                  JSR     INIT_FWD                                                                

                  BRA     EXIT                                                                    

                       

ALL_STP_ST        BRSET   PORTAD0, %00000100, NO_START_BUMP                                       

                  MOVB    #START, CRNT_STATE                                                      

NO_START_BUMP     RTS                                                                             





; Initialization Subroutines

;***************************************************************************************************

; Right turn

INIT_RIGHT        BSET    PORTA,%00000010           

                  BCLR    PORTA,%00000001           

                  LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn

                  ADDA    #T_R

                  STAA    T_TURN

                  RTS



; Left turn                  

INIT_LEFT         BSET    PORTA,%00000001          

                  BCLR    PORTA,%00000010           

                  LDAA    TOF_COUNTER               ; Mark the current TOF time

                  ADDA    #T_L                     
                  STAA    T_TURN                    ; store in T_TURN to read later on

                  RTS



; Forward 

INIT_FWD          BCLR    PORTA, %00000011         

                  BSET    PTT, %00110000            
                  RTS

                 

; Reverse  

INIT_REV          BSET PORTA,%00000011              

                  BSET PTT,%00110000               

                  RTS



; Stop                  

INIT_STOP         BCLR    PTT, %00110000            ; Turn off the drive motors

                  RTS





;***************************************************************************************************

;       Initialize Sensors

INIT              BCLR   DDRAD,$FF ; Make PORTAD an input 

                  BSET   DDRA,$FF  ; Make PORTA an output 

                  BSET   DDRB,$FF  ; Make PORTB an output 

                  BSET   DDRJ,$C0  ; Make pins 7,6 of PTJ outputs 

                  RTS





;***************************************************************************************************

;        Initialize ADC              

openADC           MOVB   #$80,ATDCTL2    ; Turn on ADC 

                  LDY    #1              ; Wait for 50 us for ADC to be ready

                  JSR    del_50us        ; 

                  MOVB   #$20,ATDCTL3    ; 4 conversions on channel AN1 

                  MOVB   #$97,ATDCTL4    ; 8-bit resolution, prescaler=48 

                  RTS



;---------------------------------------------------------------------------

;                           Clear LCD Buffer -Taken from provided Guider code

; This routine writes ’space’ characters (ascii 20) into the LCD display

; buffer in order to prepare it for the building of a new display buffer.

; This needs only to be done once at the start of the program. Thereafter the

; display routine should maintain the buffer properly.



CLR_LCD_BUF       LDX   #CLEAR_LINE

                  LDY   #TOP_LINE

                  JSR   STRCPY

             

CLB_SECOND        LDX   #CLEAR_LINE

                  LDY   #BOT_LINE

                  JSR   STRCPY

             

CLB_EXIT          RTS



; -------------------------------------------------------------------------------------------------      
                                                                                                   
; String Copy  -Taken from provided Guider code                                                    |
                                                                                                   
; Copies a null-terminated string (including the null) from one location to                        |                                                                           
; another                                                                                          |

; Passed: X contains starting address of null-terminated string                                    |

; Y contains first address of destination                                                          |
;--------------------------------------------------------------------------------------------------


STRCPY            PSHX            ; Protect the registers used

                  PSHY

                  PSHA

STRCPY_LOOP       LDAA 0,X        ; Get a source character

                  STAA 0,Y        ; Copy it to the destination

                  BEQ STRCPY_EXIT ; If it was the null, then exit

                  INX             ; Else increment the pointers

                  INY

                  BRA STRCPY_LOOP ; and do it again

STRCPY_EXIT       PULA            ; Restore the registers

                  PULY

                  PULX

                  RTS  

                     

; -------------------------------------------------------------------------------------------------      

;                                   Guider LEDs ON  -Taken from provided Guider code                                             

; This routine enables the guider LEDs so that readings of the sensor                              |

; correspond to the ’illuminated’ situation.                                                       |

; Passed: Nothing                                                                                  |

; Returns: Nothing                                                                                 |

; Side: PORTA bit 5 is changed                                                                     |

; -------------------------------------------------------------------------------------------------      

G_LEDS_ON         BSET PORTA,%00100000 ; Set bit 5                                                 |

                  RTS                                                                             ;|

; -------------------------------------------------------------------------------------------------      





; -------------------------------------------------------------------------------------------------      

;                                   Guider LEDs OFF     -Taken from provided Guider code                                    

; This routine disables the guider LEDs. Readings of the sensor                                    |

; correspond to the ’ambient lighting’ situation.                                                  |

; Passed: Nothing                                                                                  |

; Returns: Nothing                                                                                 |

; Side: PORTA bit 5 is changed                                                                     |

; -------------------------------------------------------------------------------------------------                                                                                                      

G_LEDS_OFF        BCLR PORTA,%00100000 ; Clear bit 5                                               |

                  RTS                                                                             ;|

; -------------------------------------------------------------------------------------------------      



             

; -------------------------------------------------------------------------------------------------      

;                               Read Sensors -Taken from provided Guider code

; -------------------------------------------------------------------------------------------------      

READ_SENSORS      CLR   SENSOR_NUM        ; Select sensor number 0

                  LDX   #SENSOR_LINE      ; Point at the start of the sensor array

RS_MAIN_LOOP      LDAA  SENSOR_NUM        ; Select the correct sensor input

                  JSR   SELECT_SENSOR     ; on the hardware

                  LDY   #400              ; 20 ms delay to allow the

                  JSR   del_50us          ; sensor to stabilize

                  LDAA  #%10000001        ; Start A/D conversion on AN1

                  STAA  ATDCTL5

                  BRCLR ATDSTAT0,$80,*    ; Repeat until A/D signals done

                  LDAA  ATDDR0L           ; A/D conversion is complete in ATDDR0L

                  STAA  0,X               ; so copy it to the sensor register

                  CPX   #SENSOR_STBD      ; If this is the last reading

                  BEQ   RS_EXIT           ; Then exit

                  INC   SENSOR_NUM        ; Else, increment the sensor number

                  INX                     ; and the pointer into the sensor array

                  BRA   RS_MAIN_LOOP      ; and do it again

RS_EXIT           RTS

             



; -------------------------------------------------------------------------------------------------      

;                               Select Sensor  -Taken from provided Guider code

; -------------------------------------------------------------------------------------------------      

SELECT_SENSOR     PSHA              ; Save the sensor number for the moment

                  LDAA PORTA        ; Clear the sensor selection bits to zeros

                  ANDA #%11100011   ;

                  STAA TEMP         ; and save it into TEMP

                  PULA              ; Get the sensor number

                  ASLA              ; Shift the selection number left, twice

                  ASLA ;

                  ANDA #%00011100   ; Clear irrelevant bit positions

                  ORAA TEMP         ; OR it into the sensor bit positions

                  STAA PORTA        ; Update the hardware

                  RTS



DP_FRONT_SENSOR   EQU TOP_LINE+3

DP_PORT_SENSOR    EQU BOT_LINE+0

DP_MID_SENSOR     EQU BOT_LINE+3

DP_STBD_SENSOR    EQU BOT_LINE+6

DP_LINE_SENSOR    EQU BOT_LINE+9

             

DISPLAY_SENSORS   LDAA  SENSOR_BOW        ; Get the FRONT sensor value

                  JSR   BIN2ASC           ; Convert to ascii string in D

                  LDX   #DP_FRONT_SENSOR  ; Point to the LCD buffer position

                  STD   0,X               ; and write the 2 ascii digits there

                 

                  LDAA  SENSOR_PORT       ; Repeat for the PORT value

                  JSR   BIN2ASC

                  LDX   #DP_PORT_SENSOR

                  STD   0,X

                 

                  LDAA  SENSOR_MID        ; Repeat for the MID value

                  JSR   BIN2ASC

                  LDX   #DP_MID_SENSOR

                  STD   0,X

                 

                  LDAA  SENSOR_STBD       ; Repeat for the STARBOARD value

                  JSR   BIN2ASC

                  LDX   #DP_STBD_SENSOR

                  STD   0,X

                 

                  LDAA  SENSOR_LINE       ; Repeat for the LINE value

                  JSR   BIN2ASC

                  LDX   #DP_LINE_SENSOR

                  STD   0,X

                 

                  LDAA  #CLEAR_HOME       ; Clear the display and home the cursor

                  JSR   cmd2LCD           ; "

                 

                  LDY   #40               ; Wait 2 ms until "clear display" command is complete

                  JSR   del_50us

                 

                  LDX   #TOP_LINE         ; Now copy the buffer top line to the LCD

                  JSR   putsLCD

                 

                  LDAA  #LCD_SEC_LINE     ; Position the LCD cursor on the second line

                  JSR   LCD_POS_CRSR

                 

                  LDX   #BOT_LINE         ; Copy the buffer bottom line to the LCD

                  JSR   putsLCD

                  RTS



; utility subroutines  

;***************************************************************************************************

initLCD:          LDY     #2000

                  JSR     del_50us

                  LDAA    #$28

                  JSR     cmd2LCD

                  LDAA    #$0C

                  JSR     cmd2LCD

                  LDAA    #$06

                  JSR     cmd2LCD

                  RTS

                 

;***************************************************************************************************

clrLCD:           LDAA  #$01

                  JSR   cmd2LCD

                  LDY   #40

                  JSR   del_50us

                  RTS

                 

;***************************************************************************************************

del_50us          PSHX            ; (2 E-clk) Protect the X register

eloop             LDX   #300      ; (2 E-clk) Initialize the inner loop counter

iloop             NOP             ; (1 E-clk) No operation

                  DBNE X,iloop    ; (3 E-clk) If the inner cntr not 0, loop again

                  DBNE Y,eloop    ; (3 E-clk) If the outer cntr not 0, loop again

                  PULX            ; (3 E-clk) Restore the X register

                  RTS             ; (5 E-clk) Else return

                 

;***************************************************************************************************

cmd2LCD:          BCLR  LCD_CNTR, LCD_RS  ; select the LCD instruction

                  JSR   dataMov           ; send data to IR

                  RTS

                 

;***************************************************************************************************

putsLCD:          LDAA  1,X+       ; get one character from  string

                  BEQ   donePS     ; get NULL character

                  JSR   putcLCD

                  BRA   putsLCD

donePS            RTS



;***************************************************************************************************

putcLCD:          BSET  LCD_CNTR, LCD_RS  ; select the LCD data register (DR)c

                  JSR   dataMov            ; send data to DR

                  RTS

                 

;***************************************************************************************************

dataMov:          BSET  LCD_CNTR, LCD_E ; pull LCD E-signal high

                  STAA  LCD_DAT         ; send the upper 4 bits of data to LCD

                  BCLR  LCD_CNTR, LCD_E ; pull the LCD E-signal low to complete write oper.

               

                  LSLA                  ; match the lower 4 bits with LCD data pins

                  LSLA                  ; ""

                  LSLA                  ; ""

                  LSLA                  ; ""

               

                  BSET  LCD_CNTR, LCD_E ; pull LCD E-signal high

                  STAA  LCD_DAT         ; send the lower 4 bits of data to LCD

                  BCLR  LCD_CNTR, LCD_E ; pull the LCD E-signal low to complete write oper.

               

                  LDY   #1              ; adding this delay allows

                  JSR   del_50us        ; completion of most instructions

                  RTS



;***************************************************************************************************

initAD            MOVB  #$C0,ATDCTL2    ;power up AD, select fast flag clear

                  JSR   del_50us        ;wait for 50 us

                  MOVB  #$00,ATDCTL3    ;8 conversions in a sequence

                  MOVB  #$85,ATDCTL4    ;res=8, conv-clks=2, prescal=12

                  BSET  ATDDIEN,$0C     ;configure pins AN03,AN02 as digital inputs

                  RTS

                 

;***************************************************************************************************

int2BCD           XGDX              ;Save the binary number into .X

                  LDAA #0           ;Clear the BCD_BUFFER

                  STAA TEN_THOUS

                  STAA THOUSANDS

                  STAA HUNDREDS

                  STAA TENS

                  STAA UNITS

                  STAA BCD_SPARE

                  STAA BCD_SPARE+1

                 

                  CPX #0            ; Check for a zero input

                  BEQ CON_EXIT      ; and if so, exit

                 

                  XGDX              ; Not zero, get the binary number back to .D as dividend

                  LDX #10           ; Setup 10 (Decimal!) as the divisor

                  IDIV              ; Divide Quotient is now in .X, remainder in .D

                  STAB UNITS        ; Store remainder

                  CPX #0            ; If quotient is zero,

                  BEQ CON_EXIT      ; then exit

                 

                  XGDX              ; else swap first quotient back into .D

                  LDX #10           ; and setup for another divide by 10

                  IDIV

                  STAB TENS

                  CPX #0

                  BEQ CON_EXIT

                 

                  XGDX              ; Swap quotient back into .D

                  LDX #10           ; and setup for another divide by 10

                 

                  IDIV

                  STAB HUNDREDS

                  CPX #0

                  BEQ CON_EXIT

                 

                  XGDX              ; Swap quotient back into .D

                  LDX #10           ; and setup for another divide by 10

                  IDIV

                  STAB THOUSANDS

                  CPX #0

                  BEQ CON_EXIT

                 

                  XGDX              ; Swap quotient back into .D

                  LDX #10           ; and setup for another divide by 10

                  IDIV

                  STAB TEN_THOUS

           

CON_EXIT          RTS               ; We’re done the conversion



; Cursor Positioning Subroutine

LCD_POS_CRSR      ORAA #%10000000   ; Set the high bit of the control word

                  JSR cmd2LCD       ; and set the cursor address

                  RTS

                 

;***************************************************************************************************

BIN2ASC               PSHA                    ; Save a copy of the input number

                      TAB            

                      ANDB #%00001111         ; Strip off the upper nibble

                      CLRA                    ; D now contains 000n where n is the LSnibble

                      ADDD #HEX_TABLE         ; Set up for indexed load

                      XGDX                

                      LDAA 0,X                ; Get the LSnibble character



                      PULB                    ; Retrieve the input number into ACCB

                      PSHA                    ; and push the LSnibble character in its place

                      RORB                    ; Move the upper nibble of the input number

                      RORB                    ;  into the lower nibble position.

                      RORB

                      RORB

                      ANDB #%00001111         ; Strip off the upper nibble

                      CLRA                    ; D now contains 000n where n is the MSnibble

                      ADDD #HEX_TABLE         ; Set up for indexed load

                      XGDX                                                              

                      LDAA 0,X                ; Get the MSnibble character into ACCA

                      PULB                    ; Retrieve the LSnibble character into ACCB



                      RTS

;***************************************************************************************************

;* BCD to ASCII Conversion Routine

;* This routine converts the BCD number in the BCD_BUFFER

;* into ascii format, with leading zero suppression.

;* Leading zeros are converted into space characters.

;* The flag ’NO_BLANK’ starts cleared and is set once a non-zero

;* digit has been detected.

;* The ’units’ digit is never blanked, even if it and all the

;* preceding digits are zero.



BCD2ASC           LDAA    #0            ; Initialize the blanking flag

                  STAA    NO_BLANK

             

C_TTHOU           LDAA    TEN_THOUS     ; Check the ’ten_thousands’ digit

                  ORAA    NO_BLANK

                  BNE     NOT_BLANK1



ISBLANK1          LDAA    #' '          ; It’s blank

                  STAA    TEN_THOUS     ; so store a space

                  BRA     C_THOU        ; and check the ’thousands’ digit

             

NOT_BLANK1        LDAA    TEN_THOUS     ; Get the ’ten_thousands’ digit

                  ORAA    #$30          ; Convert to ascii

                  STAA    TEN_THOUS

                  LDAA    #$1           ; Signal that we have seen a ’non-blank’ digit

                  STAA    NO_BLANK



C_THOU            LDAA    THOUSANDS     ; Check the thousands digit for blankness

                  ORAA    NO_BLANK      ; If it’s blank and ’no-blank’ is still zero

                  BNE     NOT_BLANK2



ISBLANK2          LDAA    #' '          ; Thousands digit is blank

                  STAA    THOUSANDS     ; so store a space

                  BRA     C_HUNS        ; and check the hundreds digit



NOT_BLANK2        LDAA    THOUSANDS     ; (similar to ’ten_thousands’ case)

                  ORAA    #$30

                  STAA    THOUSANDS

                  LDAA    #$1

               

                  STAA    NO_BLANK

             

C_HUNS            LDAA    HUNDREDS      ; Check the hundreds digit for blankness

                  ORAA    NO_BLANK      ; If it’s blank and ’no-blank’ is still zero

                  BNE     NOT_BLANK3



ISBLANK3          LDAA    #' '          ; Hundreds digit is blank

                  STAA    HUNDREDS       ; so store a space

                  BRA     C_TENS          ; and check the tens digit



NOT_BLANK3        LDAA    HUNDREDS          ; (similar to ’ten_thousands’ case)

                  ORAA    #$30

                  STAA    HUNDREDS

                  LDAA    #$1

                  STAA    NO_BLANK



C_TENS            LDAA    TENS          ; Check the tens digit for blankness

                  ORAA    NO_BLANK      ; If it’s blank and ’no-blank’ is still zero

                  BNE     NOT_BLANK4



ISBLANK4          LDAA    #' '          ; Tens digit is blank

                  STAA    TENS          ; so store a space

                  BRA     C_UNITS       ; and check the units digit



NOT_BLANK4        LDAA    TENS          ; (similar to ’ten_thousands’ case)

                  ORAA    #$30

                  STAA    TENS



C_UNITS           LDAA    UNITS         ; No blank check necessary, convert to ascii.

                  ORAA    #$30

                  STAA    UNITS



                  RTS                 ; We’re done



;***************************************************************************************************

ENABLE_TOF        LDAA    #%10000000

                  STAA    TSCR1       ; Enable TCNT

                  STAA    TFLG2       ; Clear TOF

                  LDAA    #%10000100  ; Enable TOI and select prescale factor equal to 16

                  STAA    TSCR2

                  RTS

;***************************************************************************************************

TOF_ISR           INC     TOF_COUNTER

                  LDAA    #%10000000  ; Clear

                  STAA    TFLG2       ; TOF

                  RTI

;***************************************************************************************************

;*  Update Display (Battery Voltage + Current State)  -Taken from our Lab5 *

;***************************************************************************************************

UPDT_DISPL      LDAA  #$82                      ; Move LCD cursor to the end of msg1

                JSR   cmd2LCD                   ;

               

                LDAB  CRNT_STATE                ; Display current state

                LSLB                            ; "

                LSLB                            ; "

                LSLB                            ; "

                LDX   #tab                      ; "

                ABX                             ; "

                JSR   putsLCD                   ; "

           

                LDAA  #$8F                      ; Move LCD cursor to the end of msg2

                JSR   cmd2LCD                   ; ""

                LDAA  SENSOR_BOW                ; Convert value from SENSOR_BOW to a

                JSR   BIN2ASC                   ; Two digit hexidecimal value

                JSR   putcLCD                   ; ""

                EXG   A,B                       ; ""

                JSR   putcLCD                   ; ""



                LDAA  #$92                      ; Move LCD cursor to Line position

                JSR   cmd2LCD                   ; ""

                LDAA  SENSOR_LINE               ; Convert value from SENSOR_BOW to a

                JSR   BIN2ASC                   ; Two digit hexidecimal value

                JSR   putcLCD                   ; ""

                EXG   A,B                       ; ""

                JSR   putcLCD                   ; ""



                LDAA  #$CC                      ; Move LCD cursor to Port position on 2nd row

                JSR   cmd2LCD                   ; ""

                LDAA  SENSOR_PORT               ; Convert value from SENSOR_BOW to a

                JSR   BIN2ASC                   ; Two digit hexidecimal value

                JSR   putcLCD                   ; ""

                EXG   A,B                       ; ""

                JSR   putcLCD                   ; ""



                LDAA  #$CF                      ; Move LCD cursor to Mid position on 2nd row

                JSR   cmd2LCD                   ; ""

                LDAA  SENSOR_MID                ; Convert value from SENSOR_BOW to a

                JSR   BIN2ASC                   ; Two digit hexidecimal value

                JSR   putcLCD                   ; ""

                EXG   A,B                       ; ""

                JSR   putcLCD                   ; ""



                LDAA  #$D2                      ; Move LCD cursor to Starboard position on 2nd row

                JSR   cmd2LCD                   ; ""

                LDAA  SENSOR_STBD               ; Convert value from SENSOR_BOW to a

                JSR   BIN2ASC                   ; Two digit hexidecimal value

                JSR   putcLCD                   ; ""

                EXG   A,B                       ; ""

                JSR   putcLCD                   ; ""

       

                MOVB  #$90,ATDCTL5              ; R-just., uns., sing. conv., mult., ch=0, start

                BRCLR ATDSTAT0,$80,*            ; Wait until the conver. seq. is complete

                LDAA  ATDDR0L                   ; Load the ch0 result - battery volt - into A

                LDAB  #39                       ; AccB = 39

                MUL                             ; AccD = 1st result x 39

                ADDD  #600                      ; AccD = 1st result x 39 + 600

                JSR   int2BCD

                JSR   BCD2ASC

                LDAA  #$C2                      ; move LCD cursor to the end of msg3

                JSR   cmd2LCD                   ; "                

                LDAA  TEN_THOUS                 ; output the TEN_THOUS ASCII character

                JSR   putcLCD                   ; "

                LDAA  THOUSANDS                 ; output the THOUSANDS ASCII character

                JSR   putcLCD                   ; "

                LDAA  #$2E                      ; output the HUNDREDS ASCII character

                JSR   putcLCD                   ; "

                LDAA  HUNDREDS                  ; output the HUNDREDS ASCII character

                JSR   putcLCD                   ; "                



                LDAA  #$C9                      ; Move LCD cursor to the end of msg4

                JSR   cmd2LCD

               

                BRCLR PORTAD0,#%00000100,bowON  ; If FWD_BUMP, then

                LDAA  #$20                      ;

                JSR   putcLCD                   ;

                BRA   stern_bump                ; Display 'B' on LCD

bowON:          LDAA  #$42                      ; ""

                JSR   putcLCD                   ; ""

         

stern_bump:     BRCLR PORTAD0,#%00001000,sternON; If REV_BUMP, then

                LDAA  #$20                      ;

                JSR   putcLCD                   ;

                BRA   UPDT_DISPL_EXIT           ; Display 'S' on LCD

sternON:        LDAA  #$53                      ; ""

                JSR   putcLCD                   ; ""

                

UPDT_DISPL_EXIT RTS                             ; and exit



;***************************************************************************************************

;*                                Interrupt Vectors                                                *

;***************************************************************************************************

                  ORG     $FFFE

                  DC.W    Entry ; Reset Vector

                  ORG     $FFDE

                  DC.W    TOF_ISR ; Timer Overflow Interrupt Vector